# 1、JDK和JRE的区别？ 
> JRE是java运行时环境，包含了java虚拟机，java基础类库。如果想要运行一个开发好的java程序，计算机中只需要安装JRE即可。
> 
> JDK是整个java开发的核心，如果想要开发java程序，需要安装JDK。
> 
> JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具（jdb，jps，jstack，jstat等）。
> 
> JDK是java开发的核心，JRE是java运行的核心。JDK包括JRE
# 2、JVM运行时数据区包括哪些内容？
![img_1.png](img_1.png)
> 1、程序计数器：是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，
> 分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
> 
> 2、java虚拟机栈：与程序计数器一样，也是线程私有的，生命周期与线程相同。
> 虚拟机栈描述的是java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
> 
> 3、本地方法栈：与虚拟机栈所发挥的作用是非常相似的，区别是虚拟机栈为虚拟机执行java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。
> 
> 4、java堆：java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
> 
> 5、方法区：方法区与java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
>
- JDK1.7之前，方法区位于永久代，使用的是堆内存，永久代的垃圾回收主要回收常量池的回收和类型的卸载，
- 但是永久代的垃圾回收效率低下，容易出现OOM异常。
- 从JDK1.8开始，已经彻底废弃了永久代，使用元空间来代替。元空间与永久代相比，其最大的区别在于：元空间不在虚拟机中而是使用本地内存。
- 
> 
> 6、特殊部分：运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用
> ，这部分内容在类加载后进入方法区的运行时常量池中存放。
> 
> 其中：线程私有的是程序计数器、虚拟机栈、本地方法栈，线程共享的是java堆和方法区。
# 3、JVM在创建对象时，对象分配内存的方式有哪几种？
>  分配内存地址时，主要采用两种方式：指针碰撞和空闲列表。
> 
> 指针碰撞：内存空间中，已使用的内存和未使用的内存之间有一个指针作为分界点，指针之前的内存空间已被使用，指针之后的内存空间未被使用。（更高效）
> 
> 使用条件：内存空间中的内存是规整的，即已使用的内存和未使用的内存之间没有碎片。
> 
> 空闲列表：虚拟机会维护一个列表，来记录哪些内存是可以使用的，哪些内存是已经被使用的，当需要分配内存时，虚拟机会遍历这个列表，找到一个足够大的内存空间分配给对象。（更复杂）
> 
> 使用条件：内存空间中的内存是不规整的，即已使用的内存和未使用的内存之间有碎片。

# 4、在并发情况下如何保证分配内存地址的线程安全？
> 1、CAS+失败重试：在并发情况下，多个线程同时去分配内存地址，只有一个线程能够成功，其他线程会失败，失败的线程会进行重试，直到成功为止。
> 
> 2、本地线程分配缓冲：每个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲，每个线程分配内存时，首先在本地线程分配缓冲中分配，
> 如果本地线程分配缓冲中的内存足够，就直接分配给线程，如果不够，就通过CAS+失败重试的方式分配内存。（是否使用TLAB：通过参数：-XX:+/-UseTLAB）

# 5、JVM中对象的内存布局是什么样的？
> 在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。
> 
> 对象头：对象头包含两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。
> 第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针确定该对象是哪个类的实例。
> 
> 实例数据：实例数据是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。
> 
> 对齐填充：对齐填充并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用。因为虚拟机要求对象的起始地址必须是8字节的整数倍，
> 而对象头部分正好是8字节的倍数（1倍或2倍），因此当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

# 6、JVM中对象的访问定位方式有哪几种？
> 1、句柄访问：java堆中划分出一块内存作为句柄池，reference中存储的是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息。
>
> 2、直接指针访问：java堆中直接存储对象的实例数据，reference中存储的是对象的地址。

# 7、虚拟机栈什么情况下会出现StackOverflowError异常？
> 1、线程请求的栈深度大于虚拟机所允许的最大深度，会抛出StackOverflowError异常。
> 
> 2、局部变量表中的局部变量所需的内存空间大于虚拟机所允许的最大空间，会抛出StackOverflowError异常。
